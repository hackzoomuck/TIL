## 운영체제란? (1/2)

------

정의 : 일반적으로 하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 자원을 관리하고 동작을 제어하는 시스템 소프트웨어

## 1. 프로세스 관리

운영체제에서 작동하는 응용 프로그램을 관리하는 기능이다.

프로세서(CPU)관리하는 것으로도 볼 수 있다. 현재 CPU를 점유해야 할 프로세스를 결정하고, 실제로 CPU를 프로세스에 할당하며, 이 프로세스 간 공유 자원 접근과 통신 등을 관리하게 된다.

- 프로세스, 스레드
- 스케줄링
- 동기화
- IPC 통신

## 2. 저장장치 관리

메인 메모리와 하드디스크, NAND 등을 관리하는 기능이다.

- 1차 저장창치(메인 메모리)
  - 프로세스에 할당하는 메모리 영역의 할당과 해제
  - 각 메모리 영역 간의 침범 방지
  - 메인 메모리의 효율적 활용을 위한 가상 메모리 기능
- 2차 저장장치(HDD, NAND Flash Memory 등)
  - 파일 형식의 데이터 저장
  - 이런 파일 데이터 관리를 위한 파일 시스템을 OS에서 관리
  - FAT, NTFS, EXT2, JFS, XFS 등 많은 파일 시스템들이 개발되어 사용중
- 메모리 관리
- 가상 메모리
- 파일 시스템

## 3. 네트워킹

- TCP / IP

- 기타 프로토콜

  TCP/IP 기반의 인터넷에 연결하거나, 응용 프로그램이 네트워크를 사용하려면 운영체제에서 네트워크 프로토콜을 지원해야 함. 현재 상용 OS들은 다양하고 많은 네트워크 프로토콜을 지원한다.

## 4. 사용자 관리

- 계정 관리
  - 하나의 PC에 여러 사람 사용 가능. 그래서 운영체제는 한 컴퓨터를 여러 사람이 사용하는 환경도 지원한다.
  - 운영체제는 각 계정을 관리할 수 있는 기능이 필요함.
  - 사용자 별로 프라이버시와 보안을 위해 개안 파일에 대해서 다른 사용자가 접근할 수 없도록 한다.
- 접근권한 관리
  - 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원함. (사용자관리 기능)

## 5. 디바이스 드라이버

- 순차접근 장치
- 임의접근 장치
- 네트워크 장치

운영체제는 시스템 자원, 하드웨어를 관리함. 시스템에는 여러 하드웨어가 연결되어 있음, 이것을 운영체제에서 인식하고 관리하게 만들어 응용 프로그램이 하드웨어를 사용할 수 있게 한다.

따라서, 운영체제 안에 하드웨어를 추상화 해주는 계층이 필요하다. 이 계층이 **디바이스 드라이버**이다. 하드웨어의 종류가 많은 만큼, 운영체제 내부의 디바이스 드라이버도 많이 존재한다.

------

## 프로세스 & 스레드

------

**프로세스**: 프로그램을 메모리 상에서 실행중인 작업

**스레드**: 프로세스 안에서 실행되는 여러 흐름 단위

기본적으로 프로세스마다 최소 1개의 스레드 소유(메인 스레드 포함)

프로세스는 각각 별도의 주소공간 할당(독립적)

- Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- Data: 전역변수, 정적변수, 배열 등(초기화된 데이터)
- Heap: 동적 할당 시 사용(new(), malloc() 등)
- Stack: 지역변수, 매개변수, 리턴 값(임시 메모리 영역)

스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유.

프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용.

**멀티프로세스**

' 하나의 컴퓨터에 여러 CPU장착 → 하나 이상의 프로세스들을 동시에 처리(병렬)'

장점 : 안정성(메모리 침법 문제를 OS 차원에서 해결)

단점 : 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생, Context Switching으로 인한 성능 저하

**Context Switching이란?**

프로세스의 상태 정보를 저장하고 복원하는 일련의 과정

동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말함.

프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을때 오버헤드가 발생할 문제가 존재함.

멀티 스레드

'하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것'

스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌.

장점 : 독립된 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소 전역 변수와 정적 변수에 대한 자료 공유 가능.

단점 : 안정성 문제, 하난의 스레드가 데이터 공간을 망가뜨리면, 모든 스레드가 작동 불능 상태(공유 메모리를 갖기 때문)

멀티스레드의 안전성에 대한 단점은 **Critical Section기법**을 통해 대비함.

- 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정
- 상보 배제, 진행, 한정된 대기를 충족해야함.

------

## 프로세스 주소 공간

------

'프로그램이 CPU에 의해 실행됨 → 프로세스가 생성되고 메모리에 프로세스 주소 공간이 할당됨.'

프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어져 있음.

- 코드 Segment : 프로그램 소스 코드 저장
- 데이터 Segment : 전역 변수 저장
- 스택 Segment : 함수, 지역 변수 저장

왜 구역이 나누어졌나요?

최대한 데이터를 공유하여 메모리 사용을 줄이기 위함.

Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유한다.

Stack과 Data를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것이다.



프로그램의 함수와와 지역 변수는, LIFO(Last in First out)특성을 가진 스택에서 실행된다.

따라서, 이 함수들 안에서 공통으로 사용하는 '전역 함수'는 따로 지정해주면 메모리를 아낄 수 있다.

------

## 인터럽트(Interrupt)

------

'프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하여 계속 처리하는 것'

지금 수행 중인 일보다 더 중요한 일(ex 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야한다.

외부/내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생

소프트웨어 인터럽트는 명령어의 수행에 의해 발생

**외부 인터럽트**

'입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생'

ex) 전원 이상, 기계 착오, 외부 신호, 입출력

**내부 인터럽트**

'Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할 때 발생'

ex) 0으로 나누기가 발생, 오버프로우, 명령어를 잘못 사용한 경우(Exception)

**소프트웨어 인터럽트**

'프로그램 처리 중 명령의 요청에 의해 발생한 것~~(SVC 인터럽트:SVC(SuperVisor Call) : OS 를 호출하는 동작을 수행하는 경우)~~'

ex) 사용자가 프로그램을 실행시킬 때 발생, 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.

### 인터럽트 발생 처리 과정

1)주 프로그램이 실행되다가 2)인터럽트가 발생했다.

현재 수행 중인 프로그램을 멈추고, 3)상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 4)인터럽트 서비스 루틴으로 간다.(잠시 저장하는 이유는, 6)인터럽트 서비스 루틴이 끝난 뒤 7)다시 원래 작업으로 돌아와야 하기 때문)

만약 **인터럽트 기능이 없었다면**, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야한다. (이를 **폴링(Polling)**이라고 한다.)

폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있다.

[컨트롤러가 입력을 받아들이는 방법(우선순위 판별방법) 2가지]

1. **폴링 방식**

   사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식

   인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다.(하드웨어에 비해 속도 느림)

2. **인터럽트 방식**

   MCU 자체가 하드웨적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식

   - Daisy Chain
   - 병렬 우선수위 부여

인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 실시간 대응이 필요할 때는 필수적인 기능이다.

즉, 인터럽트는 발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법이다.

------

## System Call

------

'fork(), exec(), wait()와 같은 것들은 Process 생성과 제어를 위한 System call'

- fork, exec는 새로운 Process 생성과 관련되어 있다.
- wait는 Process(Parent)가 만든 다른 Process(Child)가 끝날 때까지 기다리는 명령어다.

**fork()**

'새로운 Process를 생성할 때 사용'

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    printf("pid : %d", (int) getpid()); // pid : 29146
    
    int rc = fork();					// 주목
    
    if (rc < 0) {
        exit(1);
    }									// (1) fork 실패
    else if (rc == 0) {					// (2) child 인 경우 (fork 값이 0)
        printf("child (pid : %d)", (int) getpid());
    }
    else {								// (3) parent case
        printf("parent of %d (pid : %d)", rc, (int)getpid());
    }
}
pid : 29146

parent of 29147 (pid : 29146)

child (pid : 29147)
```

위와 같이 출력한다. (parent와 child의 순서는 non-deterministic함. 즉, 확신할 수 없음. scheduler가 결정하는 일임.)

[해석]

PID : process id, 프로세스 식별자. UNIX 시스템에서는 PID는 프로세스에게 명령을 할 때 사용함.

Fork()가 실행되는 순간, 프로세스가 하나 더 생김. 이 때 생긴 프로세스(child)는 fork를 만든 프로세스(parent)와 동일한 복사본을 갖게 된다.

이때 OS는 위와 똑같은 2개의 프로그램이 동작한다고 생각하고, fork()가 return 될 차례라고 생각한다.

그 때문에 새로 생성된 process(child)는 main에서 시작하지 않고, if문부터 시작하게 된다.

그러나, 차이점이 있다. 바로 child와 parent의 fork()값이 다르다. 따라서, 완전히 동일한 복사본이라 할 수 없다.

```c
Parent의 fork()값 => child의 pid 값

Child의 fork()값 => 0
```

parent와 child의 fork 값이 다른 점은 매우 유용한 방식이다.

그러나 Scheduler가 부모를 먼저 수행할지 아닐지는 확신할 수 없다.

**wait()**

'child 프로세스가 종료될 때까지 기다리는 작업'

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    printf("pid : %d", (int) getpid()); // pid : 29146
    
    int rc = fork();					// 주목
    
    if (rc < 0) {
        exit(1);
    }									// (1) fork 실패
    else if (rc == 0) {					// (2) child 인 경우 (fork 값이 0)
        printf("child (pid : %d)", (int) getpid());
    }
    else {								// (3) parent case
        int wc = wait(NULL)				// 추가된 부분
        printf("parent of %d (wc : %d / pid : %d)", wc, rc, (int)getpid());
    }
}
pid : 29146

child (pid : 29147)

parent of 29147 (wc : 29147 / pid : 29146)
```

wait를 통해서, child의 실행이 끝날 때까지 기다려줌, parent가 먼저 실행되더라도, wait()는 child가 끝나기 전에는 return하지 않으므로, 반드시 child가 먼저 실행됨.

**exec()**

'단순 fork는 동일한 프로세스의 내용을 여러 번 동작할 때 사용함. child에서는 parent와 다른 동작을 하고 싶을 때는 exec를 사용할 수 있음.`

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    printf("pid : %d", (int) getpid()); // pid : 29146
    
    int rc = fork();					// 주목
    
    if (rc < 0) {
        exit(1);
    }									// (1) fork 실패
    else if (rc == 0) {					// (2) child 인 경우 (fork 값이 0)
        printf("child (pid : %d)", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc");		// 내가 실행할 파일 이름
        myargs[1] = strdup("p3.c");		// 실행할 파일에 넘겨줄 argument
        myargs[2] = NULL;				// end of array
        execvp(myarges[0], myargs);		// wc 파일 실행.
        printf("this shouldn't print out") // 실행되지 않음.
    }
    else {								// (3) parent case
        int wc = wait(NULL)				// 추가된 부분
        printf("parent of %d (wc : %d / pid : %d)", wc, rc, (int)getpid());
    }
}
```

exec가 실행되면,

execvp(실행 파일, 전달 인자) 함수는 code segment영역에 실행 파일의 코드를 읽어와서 덮어 씌운다.

씌운 이후에는, heap, stack, 다른 메모리 영역이 초기화되고, OS는 그냥 실행한다. 즉, 새로운 Process를 생성하지 않고, 현재 프로그램에 wc라는 파일을 실행한다. 그로인해, execvp() 이후의 부분은 실행되지 않는다.

간단히 정리하면, fork()의 결과는 프로세스가 하나 더 생기는 것입니다.( = 프로세스 id- PID 가 완전히 다른 또 하나의 프로세스가 생기는 것)

반면 exec()실행의 결과로 생성되는 새로운 프로세스는 없고, exec()를 호출한 프로세스의 PID가 그대로 새로운 프로세스에 적용이 되며, exec()를 호출한 프로세스는 새로운 프로세스에 의해 덮어 쓰여지게 됩니다.

------

## PCB & Context Switching

------

**process Management**

'CPU가 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것을 말함'

이때, CPU는 각 프로세스들이 누군지 알아야 관리가 가능함

프로세스들의 특징을 갖고 있는 것이 바로 Process Metadata

Process Metadata

-Process ID

-Process State

-Process Priority

-CPU Registers

-Owner

-CPU Usage

-Memory Usage

**PCB(Process Control Block)**

'프로세스 메타데이터들을 저장해 놓는 곳, 한 PCB안에는 한 프로세스의 정보가 담김'

프로그램 실행→ 프로세스 생성 → 프로세스 주소 공간(코드, 데이터, 스택) 생성→ 이 프로세스의 메타데이터들이 PCB에 저장.

PCB가 왜 필요?

CPU에서는 프로세스가 상태에 따라 교체작업이 이루어진다. (Interrupt가 발생해서 할당받은 프로세스가 waiting상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때)

이때, 앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것이다.

PCB는 어떻게 관리?

Linked List 방식을 관리된다.

PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이하다.

프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거된다.

이렇게 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것을 Context Switching이라고 한다.

**Context Switching**

'CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정'

보통 인터럽트가 발생하거나, 실행 중이 CPU 사용 허가시간을 모두 소모하거나, 입출력을 위해 대기해야 하는 경우에 Context Switching이 발생한다.

즉, 프로세스가 Ready → Running, Running → Ready, Runnig → Waiting처럼 상태 변경시 발생!

**Context Switching 의 OverHead란?**

'overhead는 과부하라는 뜻으로 보통 안좋은 말로 많이 쓰인다. 하지만 프로세스 작업 중에는 OverHead를 감수해야 하는 상황이 있다.'

```c
프로세스를 수행하다가 입출력 이벤트가 발생해서 대기 상태로 전환시킴.

이때, ~~CPU를 그냥 놀게 놔두는 것보다 다른 프로세스를 수행시키는 것 효율적~~
```

즉, CPU에 계속 프로세스를 수행시키도록 하기 위해서 다른 프로세스를 실행시키고 Context Switching하는 것.

CPU가 놀지 않도록 만들고, 사용자에게 빠른 일처리를 제공함.



------

## IPC(Inter-Process Communication)

------

프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는 것. (스레드는 프로세스 안에서 자원을 공유하므로 영향을 받는다)

이런 독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 IPC 통신이다.

프로세스는 커널이 제공하는 IPC설비를 이용해 프로세스간 통신을 할 수 있게 한다.

**커널이란?**

'운영체제의 핵심적인 부분으로, 다른 모든 부분에 여러 기본적이 서비스를 제공해줌'

IPC 설비 종류도 여러가지 있다. 필요에 따라 IPC 설비를 선택해서 사욯해야 한다.

**IPC 종류**

- 익명 PIPE
  - 한쪽 방향으로만 통신이 가능한 반이중 통신
- Named PIPE(FIFO)
  - 부모 프로세스와 무관한 다른 프로세스도 통신이 간으함.
- Message Queue
  - 입출력 방식은 Named파이프와 동일
  - 메시지 큐는 파이프처럼 데이터 흐름이 아니라 메모리 공간이다.
- 공유 메모리
  - 데이터 자체를 공유하도록 지원하는 설비
  - 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용
  - 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠름
- 메모리 맵
  - 열린 파일을 메모리에 맵핑시켜서 공유, 공유 매개체가 파일+메모리
- 소켓
  - 네트워크 소켓 통신을 통해 데이터를 공유
  - 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용.

이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 **`세마포어`**와 **`뮤텍스`**를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)

------

## CPU Scheduling

------

1. 스케줄링

'CPU를 잘 사용하기 위해 프로세스를 잘 배정하기'

- 조건 : 오버헤드 ↓ /  사용율 ↑ / 기아 현상 ↓
- 목표
  1. Batch System : 가능하면 많은 일을 수행, 시간보다 처리량(throughout)이 중요
  2. Interactive System : 빠른 응답 시간. 적은 대기 시간.
  3. Real-time System : 기한(deadline) 맞추기

1. 선점/비선점 스케줄링

- 선점(preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우.
- 비선점(nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장(처리시간 예측 어려움)

1. 프로세스 상태

비선점 스케줄링 : Interrupt, Scheduler Dispatch

선점 스케줄링 : I/O or Event Wait

프로세스 상태 전이

- 승인(Admitted) : 프로세스 생성이 가능하여 승인됨.
- 스케줄러 디스패치(Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.
- 인터럽트(Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 주비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.
- 입출력 또는 이벤트 대기 (I/O or Event wait) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.
- 입출력 또는 이벤트 완료(I/O or Event Completion) : 입출력/이벤트가 끝나 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것.

1. CPU 스케줄링의 종류

- 비선점 스케줄링
  1. FCFS
  2. SJF
- 선점 스케줄링
  1. Priority Scheduling - Starviation, Aging
  2. Round Robin - Time Quantum
  3. Multilevel-Queue
  4. Multilevel-Feedback-Queue

1. CPU 스케줄링 척도

- Response Time - 작업이 처음 실행되기까지 걸린 시간
- Turnaround Time - 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때까지 걸린 시간