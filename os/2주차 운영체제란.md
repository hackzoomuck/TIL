## 운영체제란?(2/2)

------

정의 : 일반적으로 하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 자원을 관리하고 동작을 제어하는 시스템 소프트웨어

## 데드락(DeadLock)

------

'프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태, **교착 상태**

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생'

ex) 프로세스 1, 2이 자원 1,2를 모두 얻어야하는 가정.

t1: 프로세스1이 자원1을 얻음 /  프로세스2가 자원2를 얻음

t2: 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림

현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait상태에 빠짐. ⇒ DeadLock

**[주로 발생하는 경우]**

- 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
- 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이때 프로세스는 대기 상태로 들어감
- 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 '교착 상태' 발생

**[데드락 발생 조건]**

- 4가지 모두 성립해야 데드락 발생(아닐 경우 문제 해결 가능)

1. 상호 배제(Mutual exclusion)

자원은 한 번에 한 프로세스만 사용할 수 있음

1. 점유 대기(Hold and wait)

최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함

1. 비선점(No preemption)

다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

1. 순환 대기(Circular wait)

프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

**[데드락 처리]**

1. 교착 상태를 예방 & 회피

   1)예방(prevention)

   교착 상태 발생 조건 중 하나를 제거하면서 해결한다(자원 낭비 엄청 심함)

   - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
   - 점유대기 부정 : 프로세스 실행 전, 모든 자원을 할당
   - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원을 반남
   - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

   2)회피(avoidance)

   교착 상태 발생 시 피해나가는 방법

   **[은행원 알고리즘(Banker's Algorithm)]**

   - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 것에서 유래
   - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아 있게 되는지 사전에 검사하고 교착 상태 회피
   - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

2. 교착 상태를 탐지 & 회복

   교착 상태가 되도록 허용한 다음 회복시키는 방법

   1. 탐지(Detection)

   자원 할당 그래프를 통해 교착 상태를 탐지함.

   자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드(오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.) 발생함.

   1. 회복(Recovery)

   교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

   프로세스 종료 방법

   - 교착 상태의 프로세스를 모두 중지
   - 교착 상태가 제거될 때까지 하나씩 프로세스 중지

   자원 선점 방법

   - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당(해당 프로세스 일시정지 시킴)
   - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

교착 상태 해결책

[식사하는 철학자]

**1.** 왼쪽 젓가락부터 집어든다. 다른 철학자가 이미 왼쪽 젓가락을 쓰고 있다면 그가 내려놓을 때까지 생각하며 대기한다.

**2.** 왼쪽을 들었으면 오른쪽 젓가락을 든다. 들 수 없다면 1번과 마찬가지로 들 수 있을 때까지 생각하며 대기한다.

**3.** 두 젓가락을 모두 들었다면 일정 시간동안 식사를 한다.

**4.** 식사를 마쳤으면 오른쪽 젓가락을 내려놓고, 그 다음 왼쪽 젓가락을 내려놓는다.

**5.** 다시 생각하다가 배고프면 1번으로 돌아간다.

## 경쟁 상태(Race Condition)

------

'공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태'

→ 동시 접근 시 자료의 일관성을 해치는 결과가 나타남

**[Race Condition이 발생하는 경우]**

1. 커널 작업을 수행하는 중에 인터럽트 발생

- 문제점 : 커널 모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
- 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable시켜 CPU제어권을 가져가지 못하도록 한다.

1. 프로세스가 System Call(프로세스가 운영체제 커널에게, 어떤 동작의 수행을 요청하는 것)을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때

- 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우(프로세스2가 작업에 반영되지 않음)
- 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU제어권이 다른 프로세스에게 넘어가지 않도록 함.

1. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때

- 문제점 : 멀티 프로세스 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
- 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

## 세마포어(Semaphore) & 뮤텍스(Mutex)

------

'공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.'

이를 위해 나온 것이 바로 '세마포어'

**[세마포어]** : 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법

**[임계 구역(Critical Section)]**

여러 프로세스가 데이터를 공유하며 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

**[세마포어 P, V 연산]**

***예시\***

> 최초 S 값은 1이고, 현재 해당 구역을 수행할 프로세스 A, B가 있다고 가정하자

1. 먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감
2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기 상태
3. A가 임계구역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 됨
4. B는 이제 P(S)에서 while문을 빠져나올 수 있고, 임계구역으로 들어가 수행함

P: 임계 구역 들어가기 전에 수행(프로세스 진입 여부를 자원의 개수(S)를 통해 결정)

V: 임계 구역에서 나올 때 수행(자원 반납 알림, 대기 중인 프로세스를 깨우는 신호)

구현 방법

```c
P(S);
//---임계 구역---
V(S);
procedure P(S) // 최초 S값은 1임
	while S=0 do wait // S가 0면 1이 될 때까지 기다려야 함
  S := S-1 // S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함
end P

//---임계 구역---

procedure V(S) // 현재 상태는 S가 0임
	S := S+1 // S를 1로 원위치시켜 해제하는 과정
end V
```

이를 통해, 한 프로세스가 P 또는 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다. P와 V를 사용하여 임계 구역에 대한 상호배제 구현이 가능하게 되었다.

P는 임계 구역에 들어가기 전에 수행되고, V는 임계 구역에서 나올 때 수행된다. 이때 변수 값을 수정하는 연산은 모두 원자성을 만족해야 한다. 다시 말해, 한 프로세스(또는 스레드)에서 세마포어 값을 변경하는 동안 다른 프로세스가 동시에 이 값을 변경해서는 안 된다.

**[뮤텍스] :** 임계 구역을 가진 스레들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

상호 배제(**Mut**ual **Ex**clusion)의 약자이다.

해당 접근을 조율하기 위해 lock과 unlock을 사용한다.

- lock : 현재 임계 구역에 들어갈 권한을 얻어옴( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기)
- unlock : 현재 임계 구역을 모두 사용했음을 알림.(대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음)

뮤텍스는 상태가 0, 1로 이진 세마포어로 부르기도 함.

**[뮤텍스 알고리즘]**

1. 데커(Dekker)알고리즘

   flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식

   - flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 함수
   - turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수

   ```c
   while(true){
   	flag[i] = true;//프로세스 i가 임계 구역 진입 시도
   	while(flag[j]){ //프로세스 j가 현재 임계 구역에 있는지 확인
   		if(turn==j){ //j가 임계 구역 사용 중
   			flag[i] = false; //프로세스 i 진입 취소
   			while(turn == j); //turn이 j에서 변경될 때까지 대기
   			flag[i] = ture; // j가 끝나면 다시 진입 시도
   		}
   	}
   }
   //--------임계 구역
   turn = j;
   flag[i] = false;
   ```

2. 피터슨(Peterson) 알고리즘

   데커와 유사하지만, 상대방 프로세스/스레드에 진입 기회를 양보하는 것에 차이가 있음.

```
 P0: flag[0] = true // 임계 구역 사용을 원함
     turn = 1 // 1번 프로세스에게 차례가 감
     while( flag[1] && turn == 1 )
     {
          // flag[1] 이 turn[1] 을 가지고 있으므로
          //현재 사용중임
          // 임계 구역이 사용 가능한지 계속 확인
     }// 임계 구역
     ...
    // 임계 구역의 끝
   flag[0] = false
P1: flag[1] = true
    turn = 0
    while( flag[0] && turn == 0 )
    {
         // 임계 구역이 사용 가능한지 계속 확인
    }// 임계 구역
    ...
    // 임계 구역의 끝
    flag[1] = false
```

1. flag[0] = true로 설정하여 0번 스레드가 임계 영역 진입을 하고 싶다고 표시한다.
2. 이때 turn = 1을 주며 1번 프로세스가 먼저 들어가라고 양보해준다.
3. 만약 이때 컨텍스트 스위칭이 되지 않았다면 while문에 갇히게 된다.
4. 1번 프로세스가 이제 모든 작업을 끝내면 turn = 0, flag[1] = false가 되므로 0번 프로세스가 다시 돌 수 있다

\3. 제과점(Bakery) 알고리즘

여러 프로세스/스레드에 대한 처리가 가능한 알고리즘, 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.

```c
while(true){
	isReady[i] = true;
	number[i] = max(number[0~n-1]) + 1;
	isReady[i] = false;
	
	for(j=0;j<n;j++){
		while(isReady[j]);
		while(number[j] && number[j] <number[i] && j<i);
	}
}
//-----임계 구역
number[i] = 0;
```

## 페이징과 세그먼테이션

------

'다중 프로그래밍 시스템에 **여러 프로세스를 수용**하기 위해 **주기억장치를 동적 분할하는 메모리 관리 작업**이 필요하기 때문'

**[메모리 관리 기법]**

참고링크) https://knoc-story.tistory.com/8

1. 연속 메모리 관리

   '프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함'

   - 고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할(내부 단편화 발생)
     - 내부 단편화 : 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 현상
   - 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재(외부 단편화 발생)
     - 외부 단편화 :
       - 메모리가 할당 및 해제 작업의 반복으로 작은 메모리가 중간중간에 존재
       - 중간중간에 생긴 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황
       - 여유 공간이 여러 조각으로 나뉘는 현상

   1. 불연속 메모리 관리

      '프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 기법'

페이지 : 고정 사이즈의 작은 프로세스 조각

프레임 : 페이지 크기와 같은 주기억장치 메모리 조각

단편화: 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상

세그먼트 : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것

고정 크기: 페이징

가변 크기: 세그먼테이션

[단순 페이징]

각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨

외부 단편화 없음

소량의 내부 단편화 존재

[단순 세그먼테이션]

각 프로세스는 여러 세그먼트들로 나뉨

내부 단편화 없음, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드(어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.)감소

외부 단편화 존재

[가상 메모리 페이징]

단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요 없음.

필요한 페이지가 있으면 나중에 자동으로 불러들어짐.

외부 단편화 없음

복잡한 메모리 관리로 오버헤드 발생

[가상 메모리 세그먼테이션]

필요하지 않은 세그먼트들은 로드되지 않음

필요한 세그먼트 있을때 나중에 자동으로 불러들어짐

내부 단편화없음

복잡한 메모리 관리로 오버헤드 발생

## 페이지 교체 알고리즘

------

'페이지 부재 발생 → 새로운 페이지를 할당해야 함 →현재 할당된 페이지 중 어떤 것 교체할 지 결정하는 방법'

가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둔다. 하지만, 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있다.

따라서, 메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 out하고, 해당 공간에 현재 필요한 페이지를 in 시켜야 한다.

여기서 어떤 페이지를 out 시켜야할 지 정해야 한다. (이때, out되는 페이지를 victim page라고 부름)

기왕이면 수정이 되지 않는 페이지를 선택해야 좋다.

이유 = > 만약 수정되면 메인 메모리에서 내보낼 때, 하드디스크에서 또 수정을 진행해야 하므로 시간이 오래 걸림

이와 같은 상황에서 상황에 맞는 페이지 교체를 진행하기 위해 **페이지 교체 알고리즘**이 존재하는 것

**[Page Reference String]**

CPU는 논리 주소를 통해 특정 주소를 요구함.

메인 메모리에 올라와 있는 주소들은 페이지의 단위로 가져오기 때문에 페이지 번호가 연속되어 나타나게 되면 페이지 결함 발생하지 않음.

따라서 CPU의 주소 요구에 따라 페이지 결함이 일어나지 않는 부분은 생략하여 표시하는 방법이 바로 Page Reference String

[FIFO 알고리즘]

[OPT 알고리즘]

[LRU 알고리즘]